#include <iostream>
#include <string>
#include <fstream>
#include <algorithm>

using namespace std;

struct Node {
    string birthday; // Дата рождения
    string surname; // Фамилия
    string city; // Город рождения
    bool isTreeBuilt = false; // Флаг, указывающий, построено ли дерево
    Node* left = nullptr;
    Node* right = nullptr;
};

// Прототип функции для поиска узла с наименьшим значением в дереве
Node* minValueNode(Node* node);

// Создание нового узла
Node* newNode(string birthday, string surname, string city) {
    Node* temp = new Node;
    temp->birthday = birthday;
    temp->surname = surname;
    temp->city = city;
    temp->left = temp->right = nullptr;
    return temp;
}

// Функция для вставки нового узла с заданными данными в дерево
Node* insert(Node* node, string birthday, string surname, string city) {
    if (node == nullptr) {
        node = newNode(birthday, surname, city);
        node->isTreeBuilt = true; // Устанавливаем флаг, что дерево построено
    }
    else {
        if (birthday < node->birthday) {
            node->left = insert(node->left, birthday, surname, city);
        }
        else if (birthday > node->birthday) {
            node->right = insert(node->right, birthday, surname, city);
        }
    }
    return node;
}

// Функция для обхода дерева в глубину (DFS)
void DFS(Node* root) {
    if (root == nullptr) {
        return;
    }
    DFS(root->left);
    cout << root->birthday << " " << root->surname << " " << root->city << endl;
    DFS(root->right);
}

// Функция для обхода дерева в порядке "корень-левое-правое"
void rootLeftRight(Node* root) {
    if (root == nullptr) {
        return;
    }
    cout << root->birthday << " " << root->surname << " " << root->city << endl;
    rootLeftRight(root->left);
    rootLeftRight(root->right);
}

// Функция для вывода данных из дерева в файл
void rootLeftRightToFile(Node* root, ofstream& file) {
    if (root == nullptr) {
        return;
    }
    file << root->birthday << " " << root->surname << " " << root->city << endl;
    rootLeftRightToFile(root->left, file);
    rootLeftRightToFile(root->right, file);
}

// Функция для удаления узла по фамилии
Node* deleteNodeBySurname(Node* root, const string& surname) {
    bool isNodeDeleted = false; // Переменная для отслеживания удаления узла

    if (root == nullptr) {
        return root; // Возвращаем исходное дерево без изменений
    }

    if (root->surname == surname) {
        // Удаляем узел
        isNodeDeleted = true; // Устанавливаем флаг, что узел был удален
        if (root->left == nullptr) {
            Node* temp = root->right;
            delete root;
            return temp;
        }
        else if (root->right == nullptr) {
            Node* temp = root->left;
            delete root;
            return temp;
        }

        Node* temp = minValueNode(root->right);

        root->surname = temp->surname;
        root->birthday = temp->birthday;
        root->city = temp->city;

        root->right = deleteNodeBySurname(root->right, temp->surname);
    }
    else if (surname < root->surname) {
        root->left = deleteNodeBySurname(root->left, surname);
    }
    else {
        root->right = deleteNodeBySurname(root->right, surname);
    }

    return root;
}


// Функция для подсчета всех узлов
int countNodes(Node* root) {
    if (root == nullptr) {
        return 0;
    }
    return 1 + countNodes(root->left) + countNodes(root->right);
}

// Функция для поиска узла с наименьшим значением в дереве
Node* minValueNode(Node* node) {
    Node* current = node;

    while (current && current->left != nullptr) {
        current = current->left;
    }

    return current;
}

// Функция для удаления всех узлов
void deleteAllNodes(Node* root) {
    if (root == nullptr) {
        return;
    }
    deleteAllNodes(root->left);
    deleteAllNodes(root->right);
    delete root;
}

// Функция для изменения узла
void changeNode(Node* root, string birthday, string newSurname, string newCity) {
    if (root == nullptr) {
        return; // Узел не найден
    }

    if (root->birthday == birthday) {
        // Найден узел, обновляем его значения
        root->surname = newSurname;
        root->city = newCity;
    }
    else if (birthday < root->birthday) {
        // Ищем в левом поддереве
        changeNode(root->left, birthday, newSurname, newCity);
    }
    else {
        // Ищем в правом поддереве
        changeNode(root->right, birthday, newSurname, newCity);
    }
}

// Функция для вывода узлов в отсортированном порядке по дате рождения
void printSortedNodes(Node* root) {
    if (root == nullptr) {
        return;
    }
    // Выводим узлы в левом поддереве
    printSortedNodes(root->left);
    // Выводим текущий узел
    cout << root->birthday << " " << root->surname << " " << root->city << endl;
    // Выводим узлы в правом поддереве
    printSortedNodes(root->right);
}

// Функция для загрузки данных из файла и построения дерева
Node* loadDataFromFile(const string& filename) {
    ifstream file(filename);
    if (!file) {
        cerr << "Не удалось открыть файл для чтения." << endl;
        return nullptr;
    }

    Node* root = nullptr;
    string birthday, surname, city;
    while (file >> birthday >> surname >> city) {
        root = insert(root, birthday, surname, city);
    }
    file.close();
    return root;
}

// Функция для поиска однофамильцев
void findCousins(Node* root, const string& surname) {
    if (root == nullptr) {
        return;
    }
    if (root->surname == surname) {
        cout << root->birthday << " " << root->surname << " " << root->city << endl;
    }
    findCousins(root->left, surname);
    findCousins(root->right, surname);
}

// Функция для поиска максимального значения и количества узлов с этим значением
void findMaxValueAndCount(Node* root, string& maxValue, int& count) {
    if (root == nullptr) {
        return;
    }
    if (root->birthday > maxValue) {
        maxValue = root->birthday;
        count = 1;
    }
    else if (root->birthday == maxValue) {
        count++;
    }
    findMaxValueAndCount(root->left, maxValue, count);
    findMaxValueAndCount(root->right, maxValue, count);
}

// Функция для вывода максимального значения и количества узлов с этим значением
void printMaxValueAndCount(Node* root) {
    string maxValue;
    int count = 0;
    findMaxValueAndCount(root, maxValue, count);
    cout << "Максимальное значение: " << maxValue << endl;
    cout << "Количество узлов с максимальным значением: " << count << endl;
}

int main() {
    setlocale(0, "ru");
    Node* root = nullptr;
    string birthday, surname, city; // Объявление переменных здесь
    string filename; // Объявление переменной filename здесь
    ofstream file; // Объявление переменной file здесь
    char choice;
    bool isTreeCreated = false; // Добавлен флаг для отслеживания создания дерева

    do {
        if (!isTreeCreated) {
            cout << "a. Создать пустое дерево\n";
            cout << "q. Выход из программы\n";
            cout << "Выберите действие: ";
            cin >> choice;
            if (choice == 'a') {
                root = nullptr;
                cout << "Пустое дерево создано.\n";
                isTreeCreated = true; // Устанавливаем флаг, что дерево создано
                continue; // Продолжаем цикл без выхода из него
            }
            else if (choice == 'q') {
                cout << "Выход из программы.\n";
                break;
            }
            else {
                cout << "Неверный выбор. Попробуйте снова.\n";
                continue;
            }
        }
        else {
            // Остальная часть кода остается без изменений
            cout << "b. Добавить узел\n";
            cout << "c. Построить бинарное дерево поиска\n";
            cout << "d. Вывести данные в виде дерева\n";
            cout << "e. Вывести данные путем обхода дерева (корень-левое-правое)\n";
            cout << "f. Удаление узла по фамилии\n";
            cout << "g. Удаление всех узлов\n";
            cout << "h. Изменение номера узла\n";
            cout << "i. Подсчет всех узлов\n";
            cout << "j. Сохранить данные в текстовый файл\n";
            cout << "k. Вывод данных дерева в отсортированном виде по дате\n";
            cout << "l. Загрузка данных из файла и построение дерева\n";
            cout << "m. Поиск всех однофамильцев\n";
            cout << "n. Вывод максимального значения и количества узлов с этим значением\n";
            cout << "q. Выход из программы\n";
            cout << "Выберите действие: ";
            cin >> choice;
            // Остальная часть кода остается без изменений
            switch (choice) {
            case 'a':
                root = nullptr;
                cout << "Пустое дерево создано.\n";
                break;
            case 'b':
                cout << "Введите дату рождения: ";
                cin >> birthday;
                cout << "Введите фамилию: ";
                cin >> surname;
                cout << "Введите город рождения: ";
                cin >> city;
                root = insert(root, birthday, surname, city);
                cout << "Узел добавлен. Дерево построено.\n"; // Добавлено сообщение о построении дерева
                break;
            case 'c':
                if (!root) {
                    cout << "Для начала создайте узел.\n";
                }
                else if (!root->isTreeBuilt) {
                    cout << "Дерево уже построено.\n";
                }
                else {
                    // Здесь может быть логика построения дерева поиска, если она еще не реализована
                    cout << "Дерево построено.\n";
                }
                break;
            case 'd':
                if (!root) {
                    cout << "Для начала создайте узел.\n";
                }
                else {
                    cout << "Вывод данных в виде дерева:\n";
                    DFS(root);
                }
                break;
            case 'e':
                if (!root) {
                    cout << "Для начала создайте узел.\n";
                }
                else {
                    cout << "Вывод данных обходом дерева (корень-левое-правое):\n";
                    rootLeftRight(root);
                }
                break;
            case 'f': // Кейс для удаления узла по фамилии
                if (!root) {
                    cout << "Для начала создайте узел.\n";
                }
                else {
                    cout << "Введите фамилию узла для удаления: ";
                    cin >> surname;
                    Node* newRoot = deleteNodeBySurname(root, surname);
                    if (newRoot != root) { // Проверяем, изменилось ли дерево
                        root = newRoot;
                        cout << "Узел с указанной фамилией удален.\n";
                    }
                    else {
                        cout << "Узел с указанной фамилией не найден.\n";
                    }
                }
                break;
            case 'g':
                if (!root) {
                    cout << "Для начала создайте узел.\n";
                }
                else {
                    deleteAllNodes(root);
                    root = nullptr;
                    cout << "Все узлы удалены.\n";
                }
                break;
            case 'h':
                if (!root) {
                    cout << "Для начала создайте узел.\n";
                }
                else {
                    cout << "Введите дату рождения узла для изменения: ";
                    cin >> birthday;
                    cout << "Введите новую фамилию: ";
                    cin >> surname;
                    cout << "Введите новый город рождения: ";
                    cin >> city;
                    changeNode(root, birthday, surname, city);
                    cout << "Узел изменен.\n";
                }
                break;
            case 'i':
                if (!root) {
                    cout << "Узлов не обнаружено. Для начала создайте узел.\n";
                }
                else {
                    int nodeCount = countNodes(root);
                    cout << "Количество узлов в дереве: " << nodeCount << endl;
                }
                break;
            case 'j':
                if (!root) {
                    cout << "Для начала создайте узел.\n";
                }
                else {
                    cout << "Введите имя файла для сохранения данных: ";
                    cin >> filename;
                    file.open(filename); // Открытие файла здесь
                    if (file.is_open()) {
                        rootLeftRightToFile(root, file);
                        file.close();
                        cout << "Данные сохранены в файл " << filename << ".\n";
                    }
                    else {
                        cerr << "Не удалось открыть файл для записи.\n";
                    }
                }
                break;
            case 'k':
                if (!root || !root->isTreeBuilt) {
                    cout << "Ошибка: дерево поиска ещё не построено.\n";
                }
                else {
                    cout << "Вывод данных дерева в отсортированном виде по дате:\n";
                    printSortedNodes(root);
                }
                break;
            case 'l':
                cout << "Введите имя файла для загрузки данных: ";
                cin >> filename;
                file.open(filename); // Открытие файла здесь
                if (file.is_open()) {
                    root = loadDataFromFile(filename); // Обновление переменной root
                    file.close();
                    cout << "Данные загружены и дерево построено.\n";
                }
                else {
                    cerr << "Не удалось открыть файл для чтения.\n";
                }
                break;
            case 'm':
                if (!root) {
                    cout << "Для начала создайте узел.\n";
                }
                else {
                    cout << "Введите фамилию для поиска однофамильцев: ";
                    cin >> surname;
                    cout << "Однофамильцы:\n";
                    findCousins(root, surname);
                }
                break;
            case 'n':
                if (!root || !root->isTreeBuilt) {
                    cout << "Ошибка: дерево поиска ещё не построено.\n";
                }
                else {
                    cout << "Максимальное значение и количество узлов с этим значением:\n";
                    printMaxValueAndCount(root);
                }
                break;
            case 'q':
                cout << "Выход из программы.\n";
                break;
            default:
                cout << "Неверный выбор. Попробуйте снова.\n";
                break;
            }
        }
    } while (choice != 'q');

    return 0;
}
